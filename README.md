“Sometimes it is the people no one imagines anything of who do the things that no one can imagine”
― Alan Turing

###Enigma

### Self Evaluation

Overall Self-Evaluation Scores:
**Functionality: 3**
- I rated my functionality a 3 as I implemented the #encrypt and #decrypt methods successfully, in addition to the Command Line Interface. These features work as expected and work with edge cases.

**Object Oriented Programming: 4**
- I rated my Object Oriented Programming a 4 as I used a Generate Module in my project that contains the methods which generate random numbers and the days date.  This is `included` in my Enigma class where those things can be generated by the optional arguments in my `#encrypt` and `#decrypt` methods.
- The project also meets the requirements to be a 3 as each encapsulated part of the project is dedicated to the same purpose or general function of the program.  For example, there is a Shift class which processes the final shifts to be used in the encryptor.  Another example is the Module Generate with the "generatable" methods.  I also have a class dedicated to the Interface.  These sections are grouped by the type of function they provide and nothing unrelated is part of those files.

**Ruby Conventions and Mechanics: 4**
- I rated my Ruby Conventions and Mechanics meets the criteria to be a 4 as the classes and methods are all named according to the function they provide.   There are not any methods longer than 10 lines of code and I was able to use different enumerables depending on the functionality I needed.
- This also passes the criteria for scoring a 3 bcause I also have properly indented lines, text, logical spacing, and I also use a hash Instance Variable which stores the data for each encryption and decryption.  
-
**Test Driven Development: 4**
- I believe that I scored a 4 for Test Driven Development as I wrote my tests before I wrote the methods and classes which gave me a nice framework from which to build my project.
- I have used mocks in a great deal of my tests to cut down on the creation of objects within my test files and to keep the testing robust.  I also selectively use let.
- I have examples of `Integration Tests` in all of my test files to demonstrate complete functionality of all of my methods.  
- I have examples of `Unit Tests` in all of my test files to check for correct data types, types of output and input.
- Last but not least, I also have 100.0% test coverage and tests which run in under .5 seconds every time

**Version Control**
- A requirement for a passing project is that the project utilize a pull request workflow, have a minimum of 30 commits and have branches/pull requests with related functionality. All of my branches were named for a specific purpose and any code added/re-written was for the benefit of that functionality.  I also have Pull Requests full of documentation for what that Pull Request included as well as numerous commit messages to show the incremental changes.  The project is finished with 11+ pull requests and 80+ commits.
