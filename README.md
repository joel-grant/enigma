# Enigma


“Sometimes it is the people no one imagines anything of who do the things that no one can imagine”
― Alan Turing

===============================================================================
### Self Evaluation

##### Overall Self-Evaluation Scores:
- Functionality - 3
- Object Oriented Programming - 4
- Ruby Conventions and Mechanics - 4
- Test Driven Development - 4

**Functionality**
- I rated my functionality a 3 because I implemented the #encrypt and #decrypt methods successfully, in addition to the Command Line Interface. These features work as expected and work with edge cases.

**Object Oriented Programming*
- I rated my Object Oriented Programming a 4 as I used a Generate Module in my project that contains the methods which generate random numbers and the current day's date.  This is `included` in my Enigma class where those things can be generated by the optional arguments in my `#encrypt` and `#decrypt` methods.
- The project also meets the requirements to be a 3 as each encapsulated part of the project is dedicated to the same purpose or general function of the program.  For example, there is a Shift class which processes the final shifts to be used in the encryptor.  Another example is the Module Generate with the "generatable" methods.  I also have a class dedicated managing the Interface.  These sections are grouped by the type of function they provide.

**Ruby Conventions and Mechanics**
- I rated my Ruby Conventions and Mechanics as a 4 because the classes and methods are all named according to the function they provide.   There are not any methods longer than 10 lines of code and I was able to use different enumerables depending on the functionality I needed.
- This also passes the criteria for scoring a 3 bcause I also have properly indented lines, text, logical spacing, and I create a hash in each of the encrypt and decrypt methods which stores the data for each encryption and decryption as an instance variable.  

**Test Driven Development**
- I believe that I scored a 4 for Test Driven Development as I wrote my tests before I wrote the methods and classes which gave me a nice framework from which to build my project.
- I have used mocks in a great deal of my tests to cut down on the creation of objects within my test files and to keep the testing robust.  I also selectively use let.
- I have examples of `Integration Tests` in all of my test files to demonstrate complete functionality of all of my methods and their internal functions.  
- I have examples of `Unit Tests` in all of my test files to check for correct data types, types of output and input.
- Edge casese are addressed and the code will ignore and move past any special characters it might otherwise try to convert.  At the same time, it will also ignore case.
- Last but not least, I also have 100.0% test coverage and tests which run in under .2 seconds every time.

**Version Control**
- All of my branches were named for a specific purpose and any code added/re-written was for the benefit of that functionality.  I also have Pull Requests full of documentation for what that Pull Request included as well as numerous commit messages to show the incremental changes.  The project is finished with 11+ pull requests and 80+ commits.
